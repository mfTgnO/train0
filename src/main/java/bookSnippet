6.6. Developing your own collector for better performance
In section 6.4, where we discussed partitioning, you created a collector, using one of the many
convenient factory methods provided by the Collectors class, which divides the first n natural
numbers into primes and nonprimes, as shown in the following listing.195
Listing 6.6. Partitioning the first n natural numbers into primes and
nonprimes
public Map<Boolean, List<Integer>> partitionPrimes(int n) {
return IntStream.rangeClosed(2, n).boxed()
.collect(partitioningBy(candidate -> isPrime(candidate));
}
There you achieved an improvement over the original isPrime method by limiting the number of
divisors to be tested against the candidate prime to those not bigger than the candidate’s square
root:
public boolean isPrime(int candidate) {
int candidateRoot = (int) Math.sqrt((double) candidate);
return IntStream.rangeClosed(2, candidateRoot)
.noneMatch(i -> candidate % i == 0);
}
Is there a way to obtain even better performances? The answer is yes, but for this you’ll have to
develop a custom collector.