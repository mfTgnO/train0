2-9. Create Post-Processors to Validate and Modify POJOs
Problem
You want to apply tasks to all bean instances or specific types of instances during construction to validate or
modify bean properties according to particular criteria.
Solution
A bean post-processor allows bean processing before and after the initialization callback method
(i.e., the one assigned to the initMethod attribute of the @Bean annotation or the method decorated with
the @PostConstruct annotation). The main characteristic of a bean post-processor is that it processes all
the bean instances in the IoC container, not just a single bean instance. Typically, bean post-processors are
used to check the validity of bean properties, alter bean properties according to particular criteria, or apply
certain tasks to all bean instances.
Spring also supports the @Required annotation, which is backed by the built-in Spring post-processor
RequiredAnnotationBeanPostProcessor. The RequiredAnnotationBeanPostProcessor bean post-processor
checks whether all the bean properties with the @Required annotation have been set.
How It Works
Suppose you want to audit the creation of every bean. You may want to do this to debug an application, to
verify the properties of every bean, or in some other scenario. A bean post-processor is an ideal choice to
implement this feature because you don’t have to modify any preexisting POJO code.
Create POJO to Process Every Bean Instance
To write a bean post-processor, a class has to implement BeanPostProcessor. When Spring detects
a bean that implements this class, it applies the postProcessBeforeInitialization() and
postProcessAfterInitialization() methods to all bean instances managed by Spring. You can implement
any logic you want in these methods to either inspect, modify, or verify the status of a bean.
package com.apress.springrecipes.shop;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.stereotype.Component;ChAPTeR 2 ■ SPRInG CORe TASkS
62
@Component
public class AuditCheckBeanPostProcessor implements BeanPostProcessor {
public Object postProcessBeforeInitialization(Object bean, String beanName)
throws BeansException {
System.out.println("In AuditCheckBeanPostProcessor.
postProcessBeforeInitialization, processing bean type: " + bean.getClass());
return bean;
}
public Object postProcessAfterInitialization(Object bean, String beanName)
throws BeansException {
return bean;
}
}
Notice the postProcessBeforeInitialization() and postProcessAfterInitialization() methods
must return the original bean instance even if you don’t do anything in the method.
To register a bean post-processor in an application context, just annotate the class with the @Component
annotation. The application context is able to detect which bean implements the BeanPostProcessor
interface and register it to process all other bean instances in the container.
Create a POJO to Process Selected Bean Instances
During bean construction, the Spring IoC container passes all the bean instances to the bean post-processor
one by one. This means if you want to apply a bean post-processor to only certain types of beans, you must
filter the beans by checking their instance type. This allows you to apply logic more selectively across beans.
Suppose you now want to apply a bean post-processor but just to Product bean instances. The following
example is another bean post-processor that does this:
package com.apress.springrecipes.shop;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.stereotype.Component;
@Component
public class ProductCheckBeanPostProcessor implements BeanPostProcessor {
public Object postProcessBeforeInitialization(Object bean, String beanName)
throws BeansException {
if (bean instanceof Product) {
String productName = ((Product) bean).getName();
System.out.println("In ProductCheckBeanPostProcessor.
postProcessBeforeInitialization, processing Product: " + productName);
}
return bean;
}ChAPTeR 2 ■ SPRInG CORe TASkS
63
public Object postProcessAfterInitialization(Object bean, String beanName)
throws BeansException {
if (bean instanceof Product) {
String productName = ((Product) bean).getName();
System.out.println("In ProductCheckBeanPostProcessor.
postProcessAfterInitialization, processing Product: " + productName);
}
return bean;
}
}
Both the postProcessBeforeInitialization() and postProcessAfterInitialization() methods
must return an instance of the bean being processed. However, this also means you can even replace the
original bean instance with a new instance in your bean post-processor.
Verify POJO Properties with the @Required Annotation
In certain cases, it may be necessary to check whether particular properties have been set. Instead
of creating of custom post-constructor to verify the particular properties of a bean, it’s possible to
decorate a property with the @Required annotation. The @Required annotation provides access to the
RequiredAnnotationBeanPostProcessor class—a Spring bean post-processor that can check whether
certain bean properties have been set. Note that this processor can check only whether the properties have
been set but can’t check whether their value is null or something else.
Suppose that both the prefixGenerator and suffix properties are required for a sequence generator.
You can annotate their setter methods with @Required.
package com.apress.springrecipes.sequence;
import org.springframework.beans.factory.annotation.Required;
public class SequenceGenerator {
private PrefixGenerator prefixGenerator;
private String suffix;
...
@Required
public void setPrefixGenerator(PrefixGenerator prefixGenerator) {
this.prefixGenerator = prefixGenerator;
}
@Required
public void setSuffix(String suffix) {
this.suffix = suffix;
}
...
}
To ask Spring to check whether these properties have been set, you just need to enable scanning so
Spring can detect and enforce the @Required annotation. If any properties with @Required have not been set,
a BeanInitializationException error is thrown.