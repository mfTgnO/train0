2-8. Customize POJO Initialization and Destruction with
Annotations
Problem
Some POJOs have to perform certain types of initialization tasks before they’re used. These tasks can include
opening a file, opening a network/database connection, allocating memory, and so on. In addition, these
same POJOs have to perform the corresponding destruction tasks at the end of their life cycle. Therefore,
sometimes it’s necessary to customize bean initialization and destruction in the Spring IoC container.ChAPTeR 2 ■ SPRInG CORe TASkS
57
Solution
Spring can recognize initialization and destruction callback methods by setting the initMethod and
destroyMethod attributes of the @Bean definition in a Java config class. Or Spring can also recognize
initialization and destruction callback methods if POJO methods are decorated with the @PostConstruct
and @PreDestroy annotations, respectively. Spring can also delay the creation of a bean up until the point
it’s required—a process called lazy initialization—with the @Lazy annotation. Spring can also ensure the
initialization of certain beans before others with the @DependsOn annotation.
How It Works
Define methods to run before POJO initialization and destruction with @Bean. Let’s take the case of the
shopping application and consider an example involving a checkout function. Let’s modify the Cashier class
to record a shopping cart’s products and the checkout time to a text file.
package com.apress.springrecipes.shop;
import java.io.*;
import java.util.Date;
public class Cashier {
private String fileName;
private String path;
private BufferedWriter writer;
public void setFileName(String fileName) {
this.fileName = fileName;
}
public void setPath(String path) {
this.path = path;
}
public void openFile() throws IOException {
File targetDir = new File(path);
if (!targetDir.exists()) {
targetDir.mkdir();
}
File checkoutFile = new File(path, fileName + ".txt");
if (!checkoutFile.exists()) {
checkoutFile.createNewFile();
}
writer = new BufferedWriter(new OutputStreamWriter(
new FileOutputStream(checkoutFile, true)));
}ChAPTeR 2 ■ SPRInG CORe TASkS
58
public void checkout(ShoppingCart cart) throws IOException {
writer.write(new Date() + "\t" + cart.getItems() + "\r\n");
writer.flush();
}
public void closeFile() throws IOException {
writer.close();
}
}
In the Cashier class, the openFile() method first verifies whether the target directory and the file to
write the data exists. It then opens the text file in the specified system path and assigns it to the writer field.
Then each time the checkout() method is called, the date and cart items are appended to the text file.
Finally, the closeFile() method closes the file to release its system resources.
Next, let’s explore how this bean definition has to be set up in a Java config class to execute the
openFile() method just before the bean is created and the closeFile() method just before it’s destroyed.
@Configuration
public class ShopConfiguration {
@Bean(initMethod = "openFile", destroyMethod = "closeFile")
public Cashier cashier() {
String path = System.getProperty("java.io.tmpdir") + "/cashier";
Cashier c1 = new Cashier();
c1.setFileName("checkout");
c1.setPath(path);
return c1;
}
}
Notice the POJO’s initialization and destruction tasks are defined with the initMethod and destroyMethod
attributes of an @Bean annotation. With these two attributes set in the bean declaration, when the Cashier
class is created, it first triggers the openFile() method, verifying whether the target directory and the file to
write the data exist, as well as opening the file to append records. When the bean is destroyed, it triggers the
closeFile() method, ensuring the file reference is closed to release system resources.
Define Methods to Run Before POJO Initialization and Destruction with
@PostConstruct and @PreDestroy
Another alterative if you’re defining POJO instances outside a Java config class (e.g., with the @Component
annotation) is to use the @PostConstruct and @PreDestroy annotations directly in the POJO class.
@Component
public class Cashier {
@Value("checkout")
private String fileName;
@Value("c:/Windows/Temp/cashier")ChAPTeR 2 ■ SPRInG CORe TASkS
59
private String path;
private BufferedWriter writer;
public void setFileName(String fileName) {
this.fileName = fileName;
}
public void setPath(String path) {
this.path = path;
}
@PostConstruct
public void openFile() throws IOException {
File targetDir = new File(path);
if (!targetDir.exists()) {
targetDir.mkdir();
}
File checkoutFile = new File(path, fileName + ".txt");
if(!checkoutFile.exists()) {
checkoutFile.createNewFile();
}
writer = new BufferedWriter(new OutputStreamWriter(
new FileOutputStream(checkoutFile, true)));
}
public void checkout(ShoppingCart cart) throws IOException {
writer.write(new Date() + "\t" +cart.getItems() + "\r\n");
writer.flush();
}
@PreDestroy
public void closeFile() throws IOException {
writer.close();
}
}
The @Component annotation tells Spring to manage the POJO, just like it’s been used in previous recipes.
Two of the POJO fields’ values are set with the @Value annotation, a concept that was also explored in a
previous recipe. The openFile() method is decorated with the @PostConstruct annotation, which tells
Spring to execute the method right after a bean is constructed. The closeFile() method is decorated with
the @PreDestroy annotation, which tells Spring to execute the method right before a bean is destroyed.