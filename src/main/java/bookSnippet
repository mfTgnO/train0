4-2. Publish JSON with REST Services
Problem
You want to publish a JavaScript Object Notation (JSON)–based REST service with Spring.
Solution
JSON has blossomed into a favorite payload format for REST services. However, unlike most REST service
payloads, which rely on XML markup, JSON is different in the sense that its content is a special notation
based on the JavaScript language. For this recipe, in addition to relying on Spring’s REST support, you will
also use the MappingJackson2JsonView class that forms part of Spring to facilitate the publication of JSON
content.
■ Note the MappingJackson2JsonView class depends on the presence of the Jackson JSOn processor
library, version 2, which can be downloaded at http://wiki.fasterxml.com/JacksonDownload. if you are
using Maven or gradle you can simply add the Jackson library as a dependency in your projects build file.
If your Spring applications incorporate Ajax designs, it’s likely that you’ll find yourself designing REST
services that publish JSON as their payload. This is mainly because of the limited processing capabilities
in browsers. Although browsers can process and extract information from REST services that publish XML
payloads, it’s not very efficient. By instead delivering payloads in JSON, which is based on a language for
which browsers have a native interpreter—JavaScript—the processing and extraction of data becomes
more efficient. Unlike RSS and Atom feeds, which are standards, JSON has no specific structure it needs
to follow—except its syntax, which you’ll explore shortly. Therefore, a JSON element’s payload structure is
likely to be determined in coordination with the team members charged with an application’s Ajax design.Chapter 4 ■ Spring reSt
192
How It Works
The first thing you need to do is determine the information you want to publish as a JSON payload. This
information can be located in an RDBMS or text file, be accessed through JDBC or ORM, or inclusively be
part of a Spring bean or some other type of construct. Describing how to obtain this information would
go beyond the scope of this recipe, so we will assume you’ll use whatever means you deem appropriate to
access it. In case you’re unfamiliar with JSON, the following snippet illustrates a fragment of this format:
{
"glossary": {
"title": "example glossary",
"GlossDiv": {
"title": "S",
"GlossList": {
"GlossEntry": {
"ID": "SGML",
"SortAs": "SGML",
"GlossTerm": "Standard Generalized Markup Language",
"Acronym": "SGML",
"Abbrev": "ISO 8879:1986",
"GlossDef": {
"para": "A meta-markup language, used to create markup
languages such as DocBook.",
"GlossSeeAlso": ["GML", "XML"]
},
"GlossSee": "markup"
}
}
}
}
}
As you can observe, a JSON payload consists of text and separators such as { , } ,[ , ] , :, and ". We won’t
go into details about using one separator over another, but it suffices to say this type of syntax makes it easier
for a JavaScript engine to access and manipulate data than if it was to process it in an XML-type format.
Use MappingJackson2JsonView to Produce XML
Since you’ve already explored how to publish data using a REST service in recipes 4-1 and 4-3, we’ll cut to the
chase and show you the actual handler method needed in a Spring MVC controller to achieve this process.
@RequestMapping("/members")
public String getRestMembers(Model model) {
Members members = new Members();
members.addMembers(memberService.findAll());
model.addAttribute("members", members);
return "jsonmembertemplate";
}Chapter 4 ■ Spring reSt
193
You probably notice that it is quite similar to the controller method mentioned in recipe 4-1. The only
difference is that you return a different name for the view. The name of the view you are returning here,
jsonmembertemplate, is different and maps to a MappingJackson2JsonView view. You need to configure this
view in your configuration class.
@Configuration
@EnableWebMvc
@ComponentScan(basePackages = "com.apress.springrecipes.court")
public class CourtRestConfiguration {
...
@Bean
public View jsonmembertemplate() {
MappingJackson2JsonView view = new MappingJackson2JsonView();
view.setPrettyPrint(true);
return view;
}
}
The MappingJackson2JsonView view uses the Jackson2 library to convert objects to and from JSON. It uses
a Jackson2 ObjectMapper instance for the conversion. When a request is made to http://localhost:8080/
court/members.json, the controller method will be invoked, and a JSON representation will be returned.
{
"members" : {
"members" : [ {
"name" : "Marten Deinum",
"phone" : "00-31-1234567890",
"email" : "marten@deinum.biz"
}, {
"name" : "John Doe",
"phone" : "1-800-800-800",
"email" : "john@doe.com"
}, {
"name" : "Jane Doe",
"phone" : "1-801-802-803",
"email" : "jane@doe.com"
} ]
}
}
Actually, this JSON will be produced by each call to /members or /members.* (for instance, /members.xml
will also produce JSON). Let’s add the method and view from recipe 4-1 to the controller.
@Controller
public class RestMemberController {
...
@RequestMapping(value="/members", produces=MediaType.APPLICATION_XML_VALUE)
public String getRestMembersXml(Model model) {
Members members = new Members();
members.addMembers(memberService.findAll());
model.addAttribute("members", members);
return "xmlmembertemplate";
}Chapter 4 ■ Spring reSt
194
@RequestMapping(value="/members", produces= MediaType.APPLICATION_JSON_VALUE)
public String getRestMembersJson(Model model) {
Members members = new Members();
members.addMembers(memberService.findAll());
model.addAttribute("members", members);
return "jsonmembertemplate";
}
}
You have now a getMembersXml method and a getMembersJson method; both are basically the
same with the distinction that they return a different view name. Notice the produces attribute on the
@RequestMapping annotation. This is used to determine which method to call: /members.xml will now
produce XML, whereas /members.json will produce JSON.
Although this approach works, duplicating all the methods for the different supported view types isn’t a
feasible solution for enterprise applications. You could create a helper method to reduce the duplication, but
you would still need a lot of boilerplate because of the differences in the @RequestMapping annotations.
Use @ResponseBody to Produce JSON
Using a MappingJackson2JsonView to produce JSON is one way of producing results; however, as mentioned
in the previous section, it can be troublesome, especially with multiple supported view types. Instead, you
can rely on the Spring MVC HttpMessageConverters to convert an object to the representation requested by
the user. The following code shows the changes made to RestMemberController:
@Controller
public class RestMemberController {
...
@RequestMapping("/members")
@ResponseBody
public Members getRestMembers() {
Members members = new Members();
members.addMembers(memberService.findAll());
return members;
}
}
The first change is that you have now, additionally, annotated the controller method with @ResponseBody.
This annotation tells Spring MVC that the result of the method should be used as the body of the response.
Because you want JSON, this marshalling is done by the Jackson2JsonMessageConverter class provided by
Spring. The second change is that because of the @ResponseBody annotation, you don’t need the view name
anymore but can simply return the Members object.
■ Tip When using Spring 4 or higher instead of annotating the method with @ResponseBody, you can also
annotate your controller with @RestController instead of @Controller, which would give the same result.
this is especially convenient if you have a single controller with multiple methods.
These changes also allow you to clean up your configuration because you don’t need
MappingJackson2JsonView anymore.Chapter 4 ■ Spring reSt
195
package com.apress.springrecipes.court.web.config;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;
@Configuration
@EnableWebMvc
@ComponentScan(basePackages = "com.apress.springrecipes.court")
public class CourtRestConfiguration {}
When the application is deployed and you request the members from http://localhost:8080/court/
members.json, it will give the same results as before.
{
"members" : {
"members" : [ {
"name" : "Marten Deinum",
"phone" : "00-31-1234567890",
"email" : "marten@deinum.biz"
}, {
"name" : "John Doe",
"phone" : "1-800-800-800",
"email" : "john@doe.com"
}, {
"name" : "Jane Doe",
"phone" : "1-801-802-803",
"email" : "jane@doe.com"
} ]
}
}
You probably noticed that RestMemberController and CourtRestConfiguration are now the same as
in recipe 4-1. When calling http://localhost:8080/court/members.xml, you will get XML.
How is this possible without any additional configuration? Spring MVC will detect what is on the
classpath; when it automatically detects JAXB 2, Jackson, and Rome (see recipe 4-4), it will register the
appropriate HttpMessageConverter for the available technologies.
Use GSON to Produce JSON
Up until now you have been using Jackson to produce JSON from your objects; another popular library is
GSON, and Spring has out-of-the-box support for it. To use GSON, you will need to add it to your classpath
(instead of Jackson), and then it will be used to produce the JSON.
When using Maven, add the following dependency:
<dependency>
<groupId>com.google.code.gson</groupId>
<artifactId>gson</artifactId>
<version>2.8.0</version>
</dependency>Chapter 4 ■ Spring reSt
196
When using Gradle, add the following:
compile 'com.google.code.gson:gson:2.8.0'
This, just like when using Jackson, is all you need to implement JSON serialization with GSON. If you
start the application and call http://localhost:8080/court/members.json, you will still receive JSON but
now through GSON instead.