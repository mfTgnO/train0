2-18. Use AOP for introductions for POJOs
Problem
Sometimes you may have a group of classes that share a common behavior. In OOP, they must extend the
same base class or implement the same interface. This issue is actually a crosscutting concern that can be
modularized with AOP. In addition, the single inheritance mechanism of Java only allows a class to extend one
base class at most. So, you cannot inherit behaviors from multiple implementation classes at the same time.
Solution
An introduction is a special type of advice in AOP. It allows objects to implement an interface dynamically by
providing an implementation class for that interface. It seems as if objects extend an implementation class
at runtime. Moreover, you are able to introduce multiple interfaces with multiple implementation classes to
your objects at the same time. This can achieve the same effect as multiple inheritance.
How It Works
Suppose you have two interfaces, MaxCalculator and MinCalculator, to define the max() and min()
operations.
package com.apress.springrecipes.calculator;
public interface MaxCalculator {
public double max(double a, double b);
}
package com.apress.springrecipes.calculator;
public interface MinCalculator {
public double min(double a, double b);
}
Then you have an implementation for each interface with println statements to let you know when the
methods are executed.
package com.apress.springrecipes.calculator;
public class MaxCalculatorImpl implements MaxCalculator {
public double max(double a, double b) {
double result = (a >= b) ? a : b;
System.out.println("max(" + a + ", " + b + ") = " + result);
return result;
}
}
package com.apress.springrecipes.calculator;ChAPTeR 2 ■ SPRInG CORe TASkS
93
public class MinCalculatorImpl implements MinCalculator {
public double min(double a, double b) {
double result = (a <= b) ? a : b;
System.out.println("min(" + a + ", " + b + ") = " + result);
return result;
}
}
Now, suppose you want ArithmeticCalculatorImpl to perform the max() and min() calculation also.
As the Java language supports single inheritance only, it is not possible for the ArithmeticCalculatorImpl
class to extend both the MaxCalculatorImpl and MinCalculatorImpl classes at the same time. The only
possible way is to extend either class (e.g., MaxCalculatorImpl) and implement another interface (e.g.,
MinCalculator), either by copying the implementation code or by delegating the handling to the actual
implementation class. In either case, you have to repeat the method declarations.
With an introduction, you can make ArithmeticCalculatorImpl dynamically implement both the
MaxCalculator and MinCalculator interfaces by using the implementation classes MaxCalculatorImpl
and MinCalculatorImpl. It has the same effect as multiple inheritance from MaxCalculatorImpl
and MinCalculatorImpl. The idea behind an introduction is that you needn’t modify the
ArithmeticCalculatorImpl class to introduce new methods. That means you can introduce methods to
your existing classes even without source code available.
■ Tip You may wonder how an introduction can do that in Spring AOP. The answer is a dynamic proxy.
As you may recall, you can specify a group of interfaces for a dynamic proxy to implement. Introduction works
by adding an interface (e.g., MaxCalculator) to the dynamic proxy. When the methods declared in this interface
are called on the proxy object, the proxy will delegate the calls to the back-end implementation class
(e.g., MaxCalculatorImpl).
Introductions, like advices, must be declared within an aspect. You may create a new aspect or reuse an
existing aspect for this purpose. In this aspect, you can declare an introduction by annotating an arbitrary
field with the @DeclareParents annotation.
package com.apress.springrecipes.calculator;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.DeclareParents;
import org.springframework.stereotype.Component;
@Aspect
@Component
public class CalculatorIntroduction {
@DeclareParents(
value = "com.apress.springrecipes.calculator.ArithmeticCalculatorImpl",
defaultImpl = MaxCalculatorImpl.class)
public MaxCalculator maxCalculator;ChAPTeR 2 ■ SPRInG CORe TASkS
94
@DeclareParents(
value = "com.apress.springrecipes.calculator.ArithmeticCalculatorImpl",
defaultImpl = MinCalculatorImpl.class)
public MinCalculator minCalculator;
}
The value attribute of the @DeclareParents annotation type indicates which classes are the targets for
this introduction. The interface to introduce is determined by the type of the annotated field. Finally, the
implementation class used for this new interface is specified in the defaultImpl attribute.
Through these two introductions, you can dynamically introduce a couple of interfaces to the
ArithmeticCalculatorImpl class. Actually, you can specify an AspectJ type-matching expression in the
value attribute of the @DeclareParents annotation to introduce an interface to multiple classes.
As you have introduced both the MaxCalculator and MinCalculator interfaces to your arithmetic
calculator, you can cast it to the corresponding interface to perform the max() and min() calculations.
package com.apress.springrecipes.calculator;
public class Main {
public static void main(String[] args) {
...
ArithmeticCalculator arithmeticCalculator =
(ArithmeticCalculator) context.getBean("arithmeticCalculator");
...
MaxCalculator maxCalculator = (MaxCalculator) arithmeticCalculator;
maxCalculator.max(1, 2);
MinCalculator minCalculator = (MinCalculator) arithmeticCalculator;
minCalculator.min(1, 2);
}
}