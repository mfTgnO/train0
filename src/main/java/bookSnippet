2-10. Create POJOs with a Factory (Static Method, Instance
Method, Spring’s FactoryBean)
Problem
You want to create a POJO instance in the Spring IoC container by invoking a static factory method or instance
factory method. The purpose of this approach is to encapsulate the object-creation process either in a static
method or in a method of another object instance, respectively. The client who requests an object can simply
make a call to this method without knowing about the creation details. You want to create a POJO instance
in the Spring IoC container using Spring’s factory bean. A factory bean is a bean that serves as a factory for
creating other beans within the IoC container. Conceptually, a factory bean is similar to a factory method, but
it’s a Spring-specific bean that can be identified by the Spring IoC container during bean construction.
Solution
To create a POJO by invoking a static factory inside an @Bean definition of a Java configuration class, you
use standard Java syntax to call the static factory method. To create a POJO by invoking an instance factory
method inside an @Bean definition of a Java configuration class, you create a POJO to instantiate the factory
values and another POJO to act as a façade to access the factory.
As a convenience, Spring provides an abstract template class called AbstractFactoryBean to extend
Spring’s FactoryBean interface.
How It Works
You will explore the different ways of defining and using factory methods with Spring. First you will learn
how to use a static factory method, next an instance based factory method and finally you will look at the
Spring FactoryBean.
Create POJOs by Invoking a Static Factory Method
For example, you can write the following createProduct static factory method to create a product from a
predefined product ID. According to the product ID, this method decides which concrete product class to
instantiate. If there is no product matching this ID, it throws an IllegalArgumentException.
package com.apress.springrecipes.shop;
public class ProductCreator {
public static Product createProduct(String productId) {
if ("aaa".equals(productId)) {
return new Battery("AAA", 2.5);
} else if ("cdrw".equals(productId)) {
return new Disc("CD-RW", 1.5);
} else if ("dvdrw".equals(productId)) {
return new Disc("DVD-RW", 3.0);
}
throw new IllegalArgumentException("Unknown product");
}
}ChAPTeR 2 ■ SPRInG CORe TASkS
65
To create a POJO with a static factory method inside an @Bean definition of a Java configuration class,
you use regular Java syntax to call the factory method.
package com.apress.springrecipes.shop.config;
import com.apress.springrecipes.shop.Product;
import com.apress.springrecipes.shop.ProductCreator;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
@Configuration
public class ShopConfiguration {
@Bean
public Product aaa() {
return ProductCreator.createProduct("aaa");
}
@Bean
public Product cdrw() {
return ProductCreator.createProduct("cdrw");
}
@Bean
public Product dvdrw() {
return ProductCreator.createProduct("dvdrw");
}
}
Create POJOs by Invoking an Instance Factory Method
For example, you can write the following ProductCreator class by using a configurable map to store
predefined products. The createProduct() instance factory method finds a product by looking up
the supplied productId value in the map. If there is no product matching this ID, it will throw an
IllegalArgumentException.
package com.apress.springrecipes.shop;
...
public class ProductCreator {
private Map<String, Product> products;
public void setProducts(Map<String, Product> products) {
this.products = products;
}ChAPTeR 2 ■ SPRInG CORe TASkS
66
public Product createProduct(String productId) {
Product product = products.get(productId);
if (product != null) {
return product;
}
throw new IllegalArgumentException("Unknown product");
}
}
To create products from this ProductCreator, you first declare an @Bean to instantiate the factory values.
Next, you declare a second bean to act as a façade to access the factory. Finally, you can call the factory and
execute the createProduct() method to instantiate other beans.
package com.apress.springrecipes.shop.config;
import com.apress.springrecipes.shop.Battery;
import com.apress.springrecipes.shop.Disc;
import com.apress.springrecipes.shop.Product;
import com.apress.springrecipes.shop.ProductCreator;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import java.util.HashMap;
import java.util.Map;
@Configuration
public class ShopConfiguration {
@Bean
public ProductCreator productCreatorFactory() {
ProductCreator factory = new ProductCreator();
Map<String, Product> products = new HashMap<>();
products.put("aaa", new Battery("AAA", 2.5));
products.put("cdrw", new Disc("CD-RW", 1.5));
products.put("dvdrw", new Disc("DVD-RW", 3.0));
factory.setProducts(products);
return factory;
}
@Bean
public Product aaa() {
return productCreatorFactory().createProduct("aaa");
}
@Bean
public Product cdrw() {
return productCreatorFactory().createProduct("cdrw");
}ChAPTeR 2 ■ SPRInG CORe TASkS
67
@Bean
public Product dvdrw() {
return productCreatorFactory().createProduct("dvdrw");
}
}
Create POJOs Using Spring’s Factory Bean
Although you’ll seldom have to write custom factory beans, you may find it helpful to understand their
internal mechanisms through an example. For example, you can write a factory bean for creating a product
with a discount applied to the price. It accepts a product property and a discount property to apply the
discount to the product and return it as a new bean.
package com.apress.springrecipes.shop;
import org.springframework.beans.factory.config.AbstractFactoryBean;
public class DiscountFactoryBean extends AbstractFactoryBean<Product> {
private Product product;
private double discount;
public void setProduct(Product product) {
this.product = product;
}
public void setDiscount(double discount) {
this.discount = discount;
}
public Class<?> getObjectType() {
return product.getClass();
}
protected Product createInstance() throws Exception {
product.setPrice(product.getPrice() * (1 - discount));
return product;
}
}
By extending the AbstractFactoryBean class, the factory bean can simply override the
createInstance() method to create the target bean instance. In addition, you have to return the target
bean’s type in the getObjectType() method for the autowiring feature to work properly.
Next, you can declare product instances using a regular @Bean annotation to apply DiscountFactoryBean.
package com.apress.springrecipes.shop.config;
import com.apress.springrecipes.shop.Battery;
import com.apress.springrecipes.shop.Disc;
import com.apress.springrecipes.shop.DiscountFactoryBean;ChAPTeR 2 ■ SPRInG CORe TASkS
68
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
@Configuration
@ComponentScan("com.apress.springrecipes.shop")
public class ShopConfiguration {
@Bean
public Battery aaa() {
Battery aaa = new Battery("AAA", 2.5);
return aaa;
}
@Bean
public Disc cdrw() {
Disc aaa = new Disc("CD-RW", 1.5);
return aaa;
}
@Bean
public Disc dvdrw() {
Disc aaa = new Disc("DVD-RW", 3.0);
return aaa;
}
@Bean
public DiscountFactoryBean discountFactoryBeanAAA() {
DiscountFactoryBean factory = new DiscountFactoryBean();
factory.setProduct(aaa());
factory.setDiscount(0.2);
return factory;
}
@Bean
public DiscountFactoryBean discountFactoryBeanCDRW() {
DiscountFactoryBean factory = new DiscountFactoryBean();
factory.setProduct(cdrw());
factory.setDiscount(0.1);
return factory;
}
@Bean
public DiscountFactoryBean discountFactoryBeanDVDRW() {
DiscountFactoryBean factory = new DiscountFactoryBean();
factory.setProduct(dvdrw());
factory.setDiscount(0.1);
return factory;
}
}