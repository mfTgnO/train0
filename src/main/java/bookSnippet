6.6.2. Comparing collectors’ performances
The collector created with the partitioningBy factory method and the custom one you just
developed are functionally identical, but did you achieve your goal of improving the
performance of the partitioningBy collector with your custom one? Let’s write a quick harness to
check this:201
Note that a more scientific benchmarking approach would be to use a framework such as JMH,
but we didn’t want to add the complexity of using such a framework here and, for this use case,
the results provided by this small benchmarking class are accurate enough. This class partitions
the first million natural numbers into primes and nonprimes, invoking the method using the
collector created with the partitioningBy factory method 10 times and registering the fastest
execution. Running it on an Intel i5 2.4 GHz, it prints the following result:
Fastest execution done in 4716 msecs
Now replace partitionPrimes with partitionPrimesWithCustomCollector in the harness, in order
to test the performances of the custom collector you developed. Now the program prints
Fastest execution done in 3201 msecs
Not bad! This means you didn’t waste your time developing this custom collector for two
reasons: first, you learned how to implement your own collector when you need it, and second,
you achieved a performance improvement of around 32%.
Finally, it’s important to note that, as you did for the ToListCollector in listing 6.5, it’s possible
to obtain the same result by passing the three functions implementing the core logic of
PrimeNumbersCollector to the overloaded version of the collect method, taking them as
arguments:202
As you can see, in this way you can avoid creating a completely new class that implements the
Collector interface; the resulting code is more compact, even if it’s also probably less readable
and certainly less reusable.