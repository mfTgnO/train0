3-3. Intercept Requests with Handler Interceptors
Problem
Servlet filters defined by the Servlet API can pre-handle and post-handle every web request before and after
it’s handled by a servlet. You want to configure something with similar functions as filters in Spring’s web
application context to take advantage of the container features.
Moreover, sometimes you may want to pre-handle and post-handle web requests that are handled
by Spring MVC handlers and manipulate the model attributes returned by these handlers before they are
passed to the views.
Solution
Spring MVC allows you to intercept web requests for pre-handling and post-handling through handler
interceptors. Handler interceptors are configured in Spring’s web application context, so they can make
use of any container features and refer to any beans declared in the container. A handler interceptor can be
registered for particular URL mappings, so it only intercepts requests mapped to certain URLs.
Each handler interceptor must implement the HandlerInterceptor interface, which contains three
callback methods for you to implement: preHandle(), postHandle(), and afterCompletion(). The first
and second methods are called before and after a request is handled by a handler. The second method also
allows you to get access to the returned ModelAndView object, so you can manipulate the model attributes
in it. The last method is called after the completion of all request processing (i.e., after the view has been
rendered).Chapter 3 ■ Spring MVC
134
How It Works
Suppose you are going to measure each web request’s handling time by each request handler and allow the
views to show this time to the user. You can create a custom handler interceptor for this purpose.
package com.apress.springrecipes.court.web;
...
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;
public class MeasurementInterceptor implements HandlerInterceptor {
public boolean preHandle(HttpServletRequest request,
HttpServletResponse response, Object handler) throws Exception {
long startTime = System.currentTimeMillis();
request.setAttribute("startTime", startTime);
return true;
}
public void postHandle(HttpServletRequest request,
HttpServletResponse response, Object handler,
ModelAndView modelAndView) throws Exception {
long startTime = (Long) request.getAttribute("startTime");
request.removeAttribute("startTime");
long endTime = System.currentTimeMillis();
modelAndView.addObject("handlingTime", endTime - startTime);
}
public void afterCompletion(HttpServletRequest request,
HttpServletResponse response, Object handler, Exception ex)
throws Exception {
}
}
In the preHandle() method of this interceptor, you record the start time and save it to a request
attribute. This method should return true, allowing DispatcherServlet to proceed with request
handling. Otherwise, DispatcherServlet assumes that this method has already handled the request, so
DispatcherServlet returns the response to the user directly. Then, in the postHandle() method, you load
the start time from the request attribute and compare it with the current time. You can calculate the total
duration and then add this time to the model for passing to the view. Finally, as there is nothing for the
afterCompletion() method to do, you can leave its body empty.
When implementing an interface, you must implement all the methods even though you may not have
a need for all of them. A better way is to extend the interceptor adapter class instead. This class implements
all the interceptor methods by default. You can override only the methods that you need.
package com.apress.springrecipes.court.web;
...
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;
public class MeasurementInterceptor extends HandlerInterceptorAdapter {Chapter 3 ■ Spring MVC
135
public boolean preHandle(HttpServletRequest request,
HttpServletResponse response, Object handler) throws Exception {
...
}
public void postHandle(HttpServletRequest request,
HttpServletResponse response, Object handler,
ModelAndView modelAndView) throws Exception {
...
}
}
To register an interceptor, you need to modify the CourtConfiguration that was created in the first
recipe. You need to have it implement WebMvcConfigurer and override the addInterceptors method. The
method gives you access to the InterceptorRegistry, which you can use to add interceptors. The modified
class looks like the following:
@Configuration
public class InterceptorConfiguration implements WebMvcConfigurer {
@Override
public void addInterceptors(InterceptorRegistry registry) {
registry.addInterceptor(measurementInterceptor());
}
@Bean
public MeasurementInterceptor measurementInterceptor() {
return new MeasurementInterceptor();
}
...
}
Now you can show this time in welcome.jsp to verify this interceptor’s functionality. As WelcomeController
doesn’t have much to do, you may likely see that the handling time is 0 milliseconds. If this is the case, you can
add a sleep statement to this class to see a longer handling time.
<%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %>
<html>
<head>
<title>Welcome</title>
</head>
<body>
...
<hr />
Handling time : ${handlingTime} ms
</body>
</html>Chapter 3 ■ Spring MVC
136
By default HandlerInterceptors apply to all @Controllers; however, sometimes you want
to discriminate on which controllers interceptors are applied. The namespace and the Java-based
configuration allow for interceptors to be mapped to particular URLs. It is only a matter of configuration.
The following is the Java configuration of this:
package com.apress.springrecipes.court.config;
import com.apress.springrecipes.court.web.ExtensionInterceptor;
import com.apress.springrecipes.court.web.MeasurementInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
@Configuration
public class InterceptorConfiguration implements WebMvcConfigurer {
@Override
public void addInterceptors(InterceptorRegistry registry) {
registry.addInterceptor(measurementInterceptor());
registry.addInterceptor(summaryReportInterceptor())
.addPathPatterns("/reservationSummary*");
}
@Bean
public MeasurementInterceptor measurementInterceptor() {
return new MeasurementInterceptor();
}
@Bean
public ExtensionInterceptor summaryReportInterceptor() {
return new ExtensionInterceptor();
}
}
First there is the addition of the interceptor bean summaryReportInterceptor. The structure of the
backing class for this bean is identical to that of the measurementInterceptor (i.e., it implements the
HandlerInterceptor interface). However, this interceptor performs logic that should be restricted to a
particular controller, which is mapped to the /reservationSummary URI. When registering an interceptor,
you can specify which URLs it maps to; by default this takes an Ant-style expression. You pass this pattern
into the addPathPatterns method; there is also an excludePathPatterns method that you can use to
exclude the interceptor for certain URLs.