2-19. Introduce States to Your POJOs with AOP
Problem
Sometimes you may want to add new states to a group of existing objects to keep track of their usage, such
as the calling count, the last modified date, and so on. It should not be a solution if all the objects have the
same base class. However, it’s difficult to add such states to different classes if they are not in the same class
hierarchy.
Solution
You can introduce a new interface to your objects with an implementation class that holds the state field.
Then, you can write another advice to change the state according to a particular condition.ChAPTeR 2 ■ SPRInG CORe TASkS
95
How It Works
Suppose you want to keep track of the calling count of each calculator object. Since there is no field for
storing the counter value in the original calculator classes, you need to introduce one with Spring AOP. First,
let’s create an interface for the operations of a counter.
package com.apress.springrecipes.calculator;
public interface Counter {
public void increase();
public int getCount();
}
Next, just write a simple implementation class for this interface. This class has a count field for storing
the counter value.
package com.apress.springrecipes.calculator;
public class CounterImpl implements Counter {
private int count;
public void increase() {
count++;
}
public int getCount() {
return count;
}
}
To introduce the Counter interface to all your calculator objects with CounterImpl as the
implementation, you can write the following introduction with a type-matching expression that
matches all the calculator implementations:
package com.apress.springrecipes.calculator;
...
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.DeclareParents;
@Aspect
@Component
public class CalculatorIntroduction {
...
@DeclareParents(
value = "com.apress.springrecipes.calculator.*CalculatorImpl",
defaultImpl = CounterImpl.class)
public Counter counter;
}ChAPTeR 2 ■ SPRInG CORe TASkS
96
This introduction introduces CounterImpl to each of your calculator objects. However, it’s still not
enough to keep track of the calling count. You have to increase the counter value each time a calculator
method is called. You can write an after advice for this purpose. Note that you must get this object but not
the target object, as only the proxy object implements the Counter interface.
package com.apress.springrecipes.calculator;
...
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.Aspect;
@Aspect
@Component
public class CalculatorIntroduction {
...
@After("execution(* com.apress.springrecipes.calculator.*Calculator.*(..))"
+ " && this(counter)")
public void increaseCount(Counter counter) {
counter.increase();
}
}
In the Main class, you can output the counter value for each of the calculator objects by casting them
into the Counter type.
package com.apress.springrecipes.calculator;
public class Main {
public static void main(String[] args) {
...
ArithmeticCalculator arithmeticCalculator =
(ArithmeticCalculator) context.getBean("arithmeticCalculator");
...
UnitCalculator unitCalculator =
(UnitCalculator) context.getBean("unitCalculator");
...
Counter arithmeticCounter = (Counter) arithmeticCalculator;
System.out.println(arithmeticCounter.getCount());
Counter unitCounter = (Counter) unitCalculator;
System.out.println(unitCounter.getCount());
}
}